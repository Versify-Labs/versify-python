import json
import time

import simplejson as json
from aws_lambda_powertools.event_handler.exceptions import BadRequestError
from pynamodb.models import Model
from shortuuid import ShortUUID


class PlatformModel(Model):
    class Meta:
        pass

    def __iter__(self):
        for name, attr in self.get_attributes().items():
            yield name, attr.serialize(getattr(self, name))

    def update(self, **args):
        # self.date_updated = int(time.time())
        super(PlatformModel, self).update(**args)

    def save(self, **args):
        # self.date_updated = int(time.time())
        super(PlatformModel, self).save(**args)

    def to_dict(self):
        item = json.loads(self.to_json())
        item.pop("PK", None)
        item.pop("SK", None)
        item.pop("GSI1PK", None)
        item.pop("GSI1SK", None)
        item.pop("GSI2PK", None)
        item.pop("GSI2SK", None)
        item.pop("version", None)
        return item


def response(action, data, object=None, url=None, has_more=None):
    if action == 'list':
        return {
            "object": object,
            "url": url,
            "has_more": has_more,
            "data":  data
        }
    return data


def generate_uuid(object):
    return f"{object}_{ShortUUID().random(length=24)}"


def get_filter_condition(model, query):
    params = ['active', 'collection', 'customer',
              'email', 'merchant', 'object_id', 'object_type',
              'order', 'product', 'transfer',  'wallet']
    condition = None
    try:
        for k, v in query.items():
            # handle special cases like boolean string, append only, etc...
            if k == 'active':
                condition &= getattr(model, k) == bool(v.lower() == 'true')
            elif k in params:
                condition &= getattr(model, k) == v
    except:
        raise BadRequestError('Invalid query parameter')
    return condition


def get_last_evaluated(account, object, starting_after):
    if starting_after:
        return {
            "account": {"S": account},
            "id": {"S": starting_after},
            "object": {"S": object}
        }
    return None


def get_update_actions(model, payload):
    actions = []
    for k, v in payload.items():
        getattr(model, k).set(v)
    return actions
